/*Hand in this file ONLY!*/
/*Hand in this file ONLY!*/
/*Hand in this file ONLY!*/

#include <deque>

void* A51Initial(unsigned long long sessionKey,unsigned int frameCounter){
/* Using this funciton to initialize your A5-1 stream cipher state.
 * sessionKey: a 64-bit unsigned integer
 *             This should be used from LSB to MSB
 *   Ex. sessionKey = 0x000000000000000b = 0b0000...00001011
 *       Then, it will be translate to "1101 0000 ... 0000" in the video
 * frameCounter: a 22-bit unsigned integer
 *               This should be used from LSB to MSB, the same as sessionKey
 * This funtion returns a structure defined by yourself to keep the 
 * stream cipher state
 */

/*Your code...*/

/* step 1  initialize three LFSR */

    std::deque<int> LFSR1(19, 0);
    std::deque<int> LFSR2(22, 0);
    std::deque<int> LFSR3(23, 0);

/* step 1 end */


/* step 2  Registers are clocked 64 times ignoring irregular clocking. */

    unsigned long long sk = sessionKey;
    int sk_bit, feedback;
    for (int i = 0; i < 64; i++)
    {
        sk_bit = sk & 1;

        feedback = LFSR1.at(18) ^ LFSR1.at(17) ^ LFSR1.at(16) ^ LFSR1.at(13) ^ sk_bit;
        LFSR1.push_front(feedback);
        LFSR1.pop_back();

        feedback = LFSR2.at(21) ^ LFSR2.at(20) ^ sk_bit;
        LFSR2.push_front(feedback);
        LFSR2.pop_back();

        feedback = LFSR3.at(22) ^ LFSR3.at(21) ^ LFSR3.at(20) ^ LFSR3.at(7) ^ sk_bit;
        LFSR3.push_front(feedback);
        LFSR3.pop_back();

        sk = sk >> 1;
    }

/* step 2 end */

/* step 3 Registers are clocked 22 times ignoring irregular clocking*/

    unsigned int fc = frameCounter;
    int fc_bit;
    for (int i = 0; i < 22; i++)
    {
        fc_bit = fc & 1;

        feedback = LFSR1.at(18) ^ LFSR1.at(17) ^ LFSR1.at(16) ^ LFSR1.at(13) ^ fc_bit;
        LFSR1.push_front(feedback);
        LFSR1.pop_back();

        feedback = LFSR2.at(21) ^ LFSR2.at(20) ^ fc_bit;
        LFSR2.push_front(feedback);
        LFSR2.pop_back();

        feedback = LFSR3.at(22) ^ LFSR3.at(21) ^ LFSR3.at(20) ^ LFSR3.at(7) ^ fc_bit;
        LFSR3.push_front(feedback);
        LFSR3.pop_back();

        fc = fc >> 1;
    }

/* step 3 end */


/* step 4 Registers are clocked 100 times with irregular clocking */

    int mj_bit;
    for (int i = 0; i < 100; i++)
    {
        mj_bit = (LFSR1.at(8) + LFSR2.at(10) + LFSR3.at(10)) / 2;

        if (mj_bit == LFSR1.at(8))
        {
            feedback = LFSR1.at(18) ^ LFSR1.at(17) ^ LFSR1.at(16) ^ LFSR1.at(13);
            LFSR1.push_front(feedback);
            LFSR1.pop_back();
        }

        if (mj_bit == LFSR2.at(10))
        {
            feedback = LFSR2.at(21) ^ LFSR2.at(20);
            LFSR2.push_front(feedback);
            LFSR2.pop_back();
        }

        if (mj_bit == LFSR3.at(10))
        {
            feedback = LFSR3.at(22) ^ LFSR3.at(21) ^ LFSR3.at(20) ^ LFSR3.at(7);
            LFSR3.push_front(feedback);
            LFSR3.pop_back();
        }
    }

/* step 4 end */


/* step 5 Registers are clocked 228 times with irregular clocking. */

    std::deque<int> key_stream;
    for (int i = 0; i < 228; i++)
    {
        key_stream.push_back((LFSR1.at(18) ^ LFSR2.at(21) ^ LFSR3.at(22)));

        mj_bit = (LFSR1.at(8) + LFSR2.at(10) + LFSR3.at(10)) / 2;

        if (mj_bit == LFSR1.at(8))
        {
            feedback = LFSR1.at(18) ^ LFSR1.at(17) ^ LFSR1.at(16) ^ LFSR1.at(13);
            LFSR1.push_front(feedback);
            LFSR1.pop_back();
        }

        if (mj_bit == LFSR2.at(10))
        {
            feedback = LFSR2.at(21) ^ LFSR2.at(20);
            LFSR2.push_front(feedback);
            LFSR2.pop_back();
        }

        if (mj_bit == LFSR3.at(10))
        {
            feedback = LFSR3.at(22) ^ LFSR3.at(21) ^ LFSR3.at(20) ^ LFSR3.at(7);
            LFSR3.push_front(feedback);
            LFSR3.pop_back();
        }
    }


    return &key_stream;

    // reverse key_stream, produce a keystream from MSB to LSB
    //std::deque<int> ks_m2l(key_stream.rbegin(), key_stream.rend());

    //return &ks_m2l;

/* step 5 end */

}
 
unsigned char A51GetByte(void* LFSR){
/* Using this function to get a 8-bit key stream from the current state
 * LFSR: the current A5-1 stream cipher state
 * This function returns an unsigned char which generated by your A5-1
 *      The 8-bit key stream is generated from MSB to LSB
 *   Ex. The generated 8-bit key stream = 0 1 0 0 1 1 0 1
 *       Then, the returned unsigned char is 0x4d = 77
 */

/*Your code...*/
    std::deque<int> *ks = static_cast<std::deque<int>*>(LFSR);
    unsigned char keychar;

    int x = 128;
    for (int i = 0; i < 8; i++)
    {
        keychar += (unsigned char) (((*ks).at(0))*x);
        (*ks).pop_front();
        x /= 2;
    }

    LFSR = ks;
    return keychar;
}
